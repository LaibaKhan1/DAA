# -*- coding: utf-8 -*-
"""DAA Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ZXD2xImspDq8I6ne70k-CEBzJoP-L7w

DAA Project: Bellman-Ford Algorithm

Name: Laiba Khan

RollNo: 21B-077-CS

Description: Finds shortest path and detects negative cycles.
"""

!pip install ipywidgets

import networkx as nx
import matplotlib.pyplot as plt
from ipywidgets import widgets, VBox, HBox, Output, Button
from IPython.display import display, clear_output

# Bellman-Ford Algorithm with Path Tracking
def bellman_ford(vertices, edges, source):
    distance = [float('inf')] * vertices
    parent = [-1] * vertices
    distance[source] = 0

    for _ in range(vertices - 1):
        for u, v, w in edges:
            if distance[u] + w < distance[v]:
                distance[v] = distance[u] + w
                parent[v] = u

    # Check for negative cycle
    for u, v, w in edges:
        if distance[u] + w < distance[v]:
            print("‚ùå Negative weight cycle detected.")
            return None, None

    return distance, parent

# Reconstruct path
def get_path(parent, target):
    path = []
    while target != -1:
        path.append(target)
        target = parent[target]
    return path[::-1]

# Visualization
def visualize_graph(vertices, edges, distances, source):
    G = nx.DiGraph()
    for i in range(vertices):
        G.add_node(i)

    for u, v, w in edges:
        G.add_edge(u, v, weight=w)

    pos = nx.spring_layout(G)
    plt.figure(figsize=(10, 7))
    nx.draw_networkx_nodes(G, pos, node_color='lightblue', node_size=700)
    nx.draw_networkx_edges(G, pos, edge_color='black')
    nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): w for u, v, w in edges})
    labels = {i: f"{i}\n({distances[i] if distances[i] != float('inf') else '‚àû'})" for i in range(vertices)}
    nx.draw_networkx_labels(G, pos, labels=labels)
    nx.draw_networkx_nodes(G, pos, nodelist=[source], node_color='red')
    plt.title("Graph with Shortest Distances")
    plt.axis('off')
    plt.show()

# Dynamic edge input
def create_edge_inputs(count):
    widgets_list = []
    for i in range(count):
        u = widgets.IntText(description=f"u{i+1}")
        v = widgets.IntText(description=f"v{i+1}")
        w = widgets.IntText(description=f"w{i+1}")
        widgets_list.append((u, v, w))
    return widgets_list

def display_edge_inputs(edge_widgets):
    return VBox([HBox([u, v, w]) for u, v, w in edge_widgets])

# Handle button click
def on_run_clicked(b):
    with output:
        clear_output()
        try:
            edges = []
            for u, v, w in edge_inputs:
                if u.value >= vertices_input.value or v.value >= vertices_input.value:
                    print("‚ùå Invalid vertex index.")
                    return
                edges.append((u.value, v.value, w.value))

            src = source_input.value
            if src >= vertices_input.value:
                print("‚ùå Source vertex out of range.")
                return

            distances, parent = bellman_ford(vertices_input.value, edges, src)

            if distances is not None:
                print(f"üìç Shortest distances from vertex {src}:\n")
                for i in range(vertices_input.value):
                    if distances[i] == float('inf'):
                        print(f"Vertex {i}: Not reachable")
                    else:
                        path = get_path(parent, i)
                        print(f"Vertex {i}: Distance = {distances[i]}, Path = {' ‚Üí '.join(map(str, path))}")
                visualize_graph(vertices_input.value, edges, distances, src)

        except Exception as e:
            print("‚ùå Error:", str(e))

# UI setup
vertices_input = widgets.IntText(description="Vertices:")
edges_input = widgets.IntText(description="Edges:")
source_input = widgets.IntText(description="Source:")
run_button = Button(description="Run Bellman-Ford", button_style='success')
output = Output()
edge_inputs = []
edge_box = VBox()

def update_edge_inputs(change):
    global edge_inputs
    edge_inputs = create_edge_inputs(edges_input.value)
    edge_box.children = [display_edge_inputs(edge_inputs)]

edges_input.observe(update_edge_inputs, names='value')
run_button.on_click(on_run_clicked)

# Display UI
display(VBox([
    HBox([vertices_input, edges_input, source_input]),
    edge_box,
    run_button,
    output
]))